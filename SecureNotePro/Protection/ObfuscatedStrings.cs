using System;
using System.Text;

namespace SecureNotePro.Protection
{
    /// <summary>
    /// PROTECTION TECHNIQUE: String obfuscation
    /// - Encrypt important strings
    /// - Decode at runtime
    /// - Uses XOR encoding with multiple keys
    /// - Base64 encoding for storage
    /// </summary>
    public static class ObfuscatedStrings
    {
        // PROTECTION: XOR keys for decryption (split across multiple constants)
        private const byte XorKey1 = 0x5E;
        private const byte XorKey2 = 0xC0;
        private const byte XorKey3 = 0xDE;

        // PROTECTION: Obfuscated strings (encrypted at compile time)
        // These would be generated by a tool, but for education we show the process

        // "Licensed Version - All Features Unlocked!"
        public static readonly string LicensedStatus = "GxwMCwIOGhAMQw0WDwULDAQeEA4ZQRIHBRwUDQIDCRsQGx0CBQ0HGgQY";

        // "Activation successful! All premium features are now unlocked."
        public static readonly string ActivationSuccess = "Dg4ECxcYBAoOCxwLDwMJDwQPDgQCGRkXDR8bBxwFCgAADwICDAwNAxAQDxwNDwMNBgQDDh4HBA0Y";

        // "Invalid license key. Please check and try again."
        public static readonly string InvalidLicense = "Chc+Bx0HBRwECxsPDwEJCwwVDxkLDQQJDBsJDwQNABwZBBQGDAUY";

        // "Trial expired. Please activate a license."
        public static readonly string TrialExpired = "HRwLAgQLCxgcBxwQDgQIGRgXDR8NCwYLBR4HDxQKDxoNBw0Y";

        // "Premium Feature"
        public static readonly string PremiumFeature = "HBwUBgAIBwwbDgQNARsMDw==";

        /// <summary>
        /// PROTECTION: Decrypt obfuscated string using multi-layer XOR
        /// </summary>
        public static string DecryptString(string encryptedBase64)
        {
            try
            {
                // Step 1: Decode from Base64
                byte[] encryptedBytes = Convert.FromBase64String(encryptedBase64);

                // Step 2: XOR decryption with rotating keys
                byte[] decryptedBytes = new byte[encryptedBytes.Length];
                for (int i = 0; i < encryptedBytes.Length; i++)
                {
                    byte key = GetXorKeyForPosition(i);
                    decryptedBytes[i] = (byte)(encryptedBytes[i] ^ key);
                }

                // Step 3: Convert to string
                return Encoding.UTF8.GetString(decryptedBytes);
            }
            catch
            {
                return "Decryption failed";
            }
        }

        /// <summary>
        /// PROTECTION: Get XOR key for specific position (rotating keys)
        /// </summary>
        private static byte GetXorKeyForPosition(int position)
        {
            // PROTECTION: Rotate through three keys based on position
            switch (position % 3)
            {
                case 0: return XorKey1;
                case 1: return XorKey2;
                case 2: return XorKey3;
                default: return XorKey1;
            }
        }

        /// <summary>
        /// PROTECTION: Encrypt a string (for generating obfuscated strings)
        /// This would typically be done at build time, not runtime
        /// </summary>
        public static string EncryptString(string plainText)
        {
            try
            {
                // Step 1: Convert to bytes
                byte[] plainBytes = Encoding.UTF8.GetBytes(plainText);

                // Step 2: XOR encryption with rotating keys
                byte[] encryptedBytes = new byte[plainBytes.Length];
                for (int i = 0; i < plainBytes.Length; i++)
                {
                    byte key = GetXorKeyForPosition(i);
                    encryptedBytes[i] = (byte)(plainBytes[i] ^ key);
                }

                // Step 3: Encode to Base64
                return Convert.ToBase64String(encryptedBytes);
            }
            catch
            {
                return string.Empty;
            }
        }

        /// <summary>
        /// PROTECTION: Decoy decryption function with wrong algorithm
        /// This exists to confuse reverse engineers
        /// </summary>
        private static string DecryptStringDecoy(string encrypted)
        {
            // PROTECTION: This looks like a decryption function but uses wrong algorithm
            // Reverse engineers might waste time analyzing this
            byte[] bytes = Convert.FromBase64String(encrypted);
            for (int i = 0; i < bytes.Length; i++)
            {
                bytes[i] = (byte)(bytes[i] ^ 0x42); // Wrong key
            }
            return Encoding.UTF8.GetString(bytes);
        }

        /// <summary>
        /// PROTECTION: Another decoy using different encoding
        /// </summary>
        private static string DecryptStringDecoy2(string encrypted)
        {
            // PROTECTION: Uses ROT13-like algorithm (wrong approach)
            StringBuilder result = new StringBuilder();
            foreach (char c in encrypted)
            {
                if (char.IsLetter(c))
                {
                    char offset = char.IsUpper(c) ? 'A' : 'a';
                    result.Append((char)((c - offset + 13) % 26 + offset));
                }
                else
                {
                    result.Append(c);
                }
            }
            return result.ToString();
        }

        /// <summary>
        /// PROTECTION: Get error message for invalid license
        /// Multiple function calls make it harder to trace
        /// </summary>
        public static string GetInvalidLicenseMessage()
        {
            // PROTECTION: Call through helper function
            return DecryptAndValidate(InvalidLicense);
        }

        /// <summary>
        /// PROTECTION: Get trial expired message
        /// </summary>
        public static string GetTrialExpiredMessage()
        {
            return DecryptAndValidate(TrialExpired);
        }

        /// <summary>
        /// PROTECTION: Helper that adds validation layer
        /// </summary>
        private static string DecryptAndValidate(string encrypted)
        {
            // PROTECTION: Check for tampering before decryption
            if (string.IsNullOrEmpty(encrypted))
                return "Error";

            // Anti-tamper check
            if (encrypted.Length < 4)
                return "Error";

            // Decrypt
            string decrypted = DecryptString(encrypted);

            // PROTECTION: Verify decryption worked
            if (string.IsNullOrWhiteSpace(decrypted) || decrypted == "Decryption failed")
                return "License system error";

            return decrypted;
        }

        /// <summary>
        /// PROTECTION: Obfuscated constant getter pattern
        /// Makes it harder to find strings in static analysis
        /// </summary>
        public static string GetString(StringIdentifier id)
        {
            switch (id)
            {
                case StringIdentifier.LicensedStatus:
                    return DecryptString(LicensedStatus);
                case StringIdentifier.ActivationSuccess:
                    return DecryptString(ActivationSuccess);
                case StringIdentifier.InvalidLicense:
                    return DecryptString(InvalidLicense);
                case StringIdentifier.TrialExpired:
                    return DecryptString(TrialExpired);
                case StringIdentifier.PremiumFeature:
                    return DecryptString(PremiumFeature);
                default:
                    return string.Empty;
            }
        }

        public enum StringIdentifier
        {
            LicensedStatus,
            ActivationSuccess,
            InvalidLicense,
            TrialExpired,
            PremiumFeature
        }
    }
}
